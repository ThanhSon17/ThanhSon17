private val messageListener = MessageClient.OnMessageReceivedListener { messageEvent ->
        if (messageEvent.path == "/test-path") {
            val message = String(messageEvent.data)
            Log.d("Watch", "Message received: $message")
        } else {
            Log.d("Watch", "Message received on unknown path: ${messageEvent.path}")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_wear)
        Log.d("Watch", "Activity created")
    }

    override fun onResume() {
        super.onResume()
        Wearable.getMessageClient(this).addListener(messageListener)
        Log.d("Watch", "MessageClient listener added")
    }

    override fun onPause() {
        super.onPause()
        Wearable.getMessageClient(this).removeListener(messageListener)
        Log.d("Watch", "MessageClient listener removed")
    }
<androidx.wear.widget.BoxInsetLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:padding="8dp"
        app:layout_boxedEdges="all">

        <ImageView
            android:id="@+id/imageView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:visibility="gone"
            android:scaleType="centerCrop"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent" />

        <ProgressBar
            android:id="@+id/progressBar"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:visibility="gone"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent" />

        <TextView
            android:id="@+id/errorText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:visibility="gone"
            android:textAlignment="center"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</androidx.wear.widget.BoxInsetLayout>

view?.showTransferProgress() // Show loading state while checking
            try {
                // Get capabilities to ensure the device can receive images
                val capabilityInfo = Tasks.await(
                    Wearable.getCapabilityClient(context)
                        .getCapability("receive_images", CapabilityClient.FILTER_REACHABLE)
                )
                
                if (capabilityInfo.nodes.isNotEmpty()) {
                    // We found a wear device that can receive images
                    view?.showImageSelectionUI()
                } else {
                    // Double check connected nodes in case capability isn't registered
                    val nodes = Tasks.await(Wearable.getNodeClient(context).connectedNodes)
                    if (nodes.isNotEmpty()) {
                        view?.showImageSelectionUI()
                    } else {
                        view?.showNoConnectedDevicesError()
                    }
                }


binding = ActivityImageReceiverBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        capabilityClient = Wearable.getCapabilityClient(this)
        
        // Advertise that this device can receive images
        CoroutineScope(Dispatchers.IO).launch {
            try {
                Tasks.await(capabilityClient.addLocalCapability("receive_images"))
            } catch (e: Exception) {
                Log.e("ImageReceiver", "Failed to advertise capability", e)
            }
        }
        
        presenter = ImageReceiverPresenter(
            this,
            Wearable.getDataClient(this)
        )
        presenter.onAttach(this)
        presenter.startListeningForImages()
    }
    
    override fun onDestroy() {
        // Remove capability when activity is destroyed
        CoroutineScope(Dispatchers.IO).launch {
            try {
                Tasks.await(capabilityClient.removeLocalCapability("receive_images"))
            } catch (e: Exception) {
                Log.e("ImageReceiver", "Failed to remove capability", e)
            }
        }
        presenter.onDetach()
        super.onDestroy()
    }


override fun checkWearDeviceConnection() {
        // Initialize on main thread
        val nodeClient = Wearable.getNodeClient(context)
        
        scope.launch {
            view?.showTransferProgress()
            try {
                // Switch to IO dispatcher for the async operation
                val nodes = withContext(Dispatchers.IO) {
                    Tasks.await(nodeClient.connectedNodes)
                }
                
                // Back on main thread
                if (nodes.isNotEmpty()) {
                    Log.d("ImageTransfer", "Found connected nodes: ${nodes.map { it.displayName }}")
                    view?.showImageSelectionUI()
                } else {
                    Log.d("ImageTransfer", "No connected nodes found")
                    view?.showNoConnectedDevicesError()
                }
            } catch (e: Exception) {
                Log.e("ImageTransfer", "Connection check failed", e)
                view?.showTransferError("Failed to check Wear device connection: ${e.message}")
            }
        }
    }

try {
                // Read image data in IO context
                val imageData = withContext(Dispatchers.IO) {
                    context.contentResolver.openInputStream(uri)?.use { 
                        it.readBytes() 
                    } ?: throw IllegalStateException("Failed to read image data")
                }
                
                // Create request on main thread
                val request = PutDataMapRequest.create("/image_transfer").apply {
                    dataMap.putAsset("image", Asset.createFromBytes(imageData))
                    dataMap.putLong("timestamp", System.currentTimeMillis())
                }.asPutDataRequest()
                    .setUrgent()
                
                // Execute data transfer in IO context
                withContext(Dispatchers.IO) {
                    Tasks.await(dataClient.putDataItem(request))
                }
                
                // Update UI on main thread
                view?.showTransferSuccess()
                Log.d("ImageTransfer", "Image transfer successful")
                
            } catch (e: Exception) {
                Log.e("ImageTransfer", "Image transfer failed", e)
                view?.showTransferError("Failed to transfer image: ${e.message}")
            }
        }
